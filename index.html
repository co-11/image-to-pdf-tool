<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç”»åƒãƒ•ã‚©ãƒ«ãƒ€ â†’ PDFå¤‰æ›ï¼ˆèµ¤æ ãƒ»ãƒã‚¹ã‚¯æ©Ÿèƒ½å¼·åŒ–ç‰ˆï¼‰</title>
  <!-- jsPDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- Cropper.js -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()"></script>
  <!-- JSZip & FileSaver (for Image/ZIP export) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <!-- Google Fonts: Roboto Mono (è¦–èªæ€§ã®é«˜ã„ç­‰å¹…ãƒ•ã‚©ãƒ³ãƒˆ) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500;700&display=swap" rel="stylesheet">
  
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Roboto Mono', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; /* UIã‚‚å°‘ã—ãƒ†ãƒƒã‚¯é¢¨ã« */
      background: #f1f5f9;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      color: #334155;
      position: relative;
    }

    /* ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ */
    .hidden { display: none !important; }

    /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
    header {
      background: white;
      padding: 12px 24px;
      border-bottom: 1px solid #e2e8f0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
      z-index: 10;
    }
    h1 { font-size: 18px; font-weight: 700; color: #1e293b; display: flex; align-items: center; gap: 8px; }
    .subtitle { font-size: 12px; color: #64748b; margin-left: 12px; }

    /* ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
    .app-layout {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* å·¦å´ï¼šãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      background: #f8fafc;
    }

    .toolbar {
      padding: 12px 16px;
      display: flex;
      gap: 12px;
      background: #f8fafc;
      border-bottom: 1px solid #e2e8f0;
      flex-shrink: 0;
      align-items: center;
    }

    /* ç”»åƒå‡¦ç†ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
    .processing-toolbar {
      padding: 8px 16px;
      background: white;
      border-bottom: 1px solid #e2e8f0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
      z-index: 5;
    }
    .proc-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .proc-title {
      font-size: 11px; font-weight: 700; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.05em;
      display: flex; align-items: center; gap: 4px;
      margin-right: 8px;
    }
    .proc-buttons {
      display: flex;
      gap: 8px;
    }
    
    /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ãƒ‘ãƒãƒ«ï¼ˆãƒˆã‚°ãƒ«ã§è¡¨ç¤ºï¼‰ */
    .slider-panel {
      padding: 16px 24px;
      background: #f1f5f9;
      border-bottom: 1px solid #cbd5e1;
      flex-shrink: 0;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .proc-sliders {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 8px 24px;
    }

    .scroll-area {
      flex: 1;
      overflow-y: auto;
      display: block; 
    }

    /* ç”»åƒã‚°ãƒªãƒƒãƒ‰ */
    .preview-grid {
      width: 100%;
      padding: 24px;
      padding-bottom: 60px;
    }

    /* ç”»åƒãŒã‚ã‚‹æ™‚ã®ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆGridï¼‰ */
    .preview-grid:not(.is-empty) {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 16px;
      align-content: start; /* ä¸Šè©°ã‚ã§é…ç½®ï¼ˆå¼•ãä¼¸ã°ã—é˜²æ­¢ï¼‰ */
      height: auto; /* ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã«å¿œã˜ã¦ä¼¸ã³ã‚‹ */
    }

    /* ç”»åƒãŒãªã„æ™‚ã®ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå…¨ç”»é¢Flexï¼‰ */
    .preview-grid.is-empty {
      display: flex;
      flex-direction: column;
      height: 100%; /* è¦ªè¦ç´ ã„ã£ã±ã„ã«åºƒã’ã‚‹ */
      align-items: center;
      justify-content: center;
    }

    .preview-item {
      position: relative;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      border: 2px solid transparent;
      transition: all 0.2s;
      cursor: pointer;
    }
    .preview-item:hover { 
      border-color: #3b82f6; 
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      transform: translateY(-2px);
    }
    .preview-item.dragging { opacity: 0.5; }

    .preview-item .img-wrapper {
      aspect-ratio: 1;
      background: #e2e8f0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      position: relative;
    }
    .preview-item img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
    }

    .preview-item .filename {
      padding: 8px;
      font-size: 11px;
      color: #475569;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      background: white;
      border-top: 1px solid #f1f5f9;
      text-align: center;
      /* ãƒ•ã‚¡ã‚¤ãƒ«åã‚‚Roboto Monoã§è¡¨ç¤º */
      font-family: 'Roboto Mono', monospace; 
    }
    .preview-item .index {
      position: absolute; top: 6px; left: 6px;
      background: rgba(15, 23, 42, 0.7); color: white;
      padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: bold;
      pointer-events: none;
      z-index: 5;
    }

    /* å³å´ï¼šã‚µã‚¤ãƒ‰ãƒãƒ¼ */
    .sidebar {
      width: 300px; 
      background: white;
      border-left: 1px solid #e2e8f0;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      flex-shrink: 0;
    }
    .sidebar-section {
      padding: 24px 20px;
      border-bottom: 1px solid #f1f5f9;
    }
    .sidebar-title {
      font-size: 13px;
      font-weight: 600;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 16px;
      display: flex; align-items: center; gap: 6px;
    }

    /* ãƒœã‚¿ãƒ³é¡ */
    .btn {
      width: 100%; padding: 10px; border: none; border-radius: 6px;
      font-size: 14px; font-weight: 500; cursor: pointer;
      display: flex; align-items: center; justify-content: center; gap: 8px;
      transition: all 0.2s; margin-bottom: 8px;
    }
    /* Toolbarç”¨ãƒœã‚¿ãƒ³èª¿æ•´ */
    .btn-sm {
        width: auto; padding: 6px 12px; font-size: 12px; margin-bottom: 0;
    }

    .btn-primary { background: #3b82f6; color: white; }
    .btn-primary:hover { background: #2563eb; }
    .btn-primary:disabled { background: #cbd5e1; cursor: not-allowed; }
    
    .btn-secondary { background: #f1f5f9; color: #475569; border: 1px solid #e2e8f0; }
    .btn-secondary:hover { background: #e2e8f0; }
    .btn-secondary.active { background: #e2e8f0; border-color: #cbd5e1; color: #1e293b; }
    
    .btn-danger { background: #fee2e2; color: #ef4444; border: 1px solid #fecaca; }
    .btn-danger:hover { background: #fecaca; }

    .btn-success { background: #10b981; color: white; }
    .btn-success:hover { background: #059669; }
    .btn-success:disabled { background: #cbd5e1; cursor: not-allowed; }
    
    .btn-outline-success { 
      background: white; color: #10b981; border: 1px solid #10b981; 
    }
    .btn-outline-success:hover { background: #ecfdf5; }

    .btn-purple { background: #8b5cf6; color: white; }
    .btn-purple:hover { background: #7c3aed; }
    .btn-purple:disabled { background: #cbd5e1; cursor: not-allowed; }

    .btn-red-outline { 
      background: white; color: #ef4444; border: 1px solid #ef4444; 
    }
    .btn-red-outline:hover { background: #fef2f2; }
    .btn-red-outline:disabled { border-color:#cbd5e1; color:#cbd5e1; background:white; cursor:not-allowed; }

    /* è¨­å®šãƒ•ã‚©ãƒ¼ãƒ  */
    .form-group { margin-bottom: 12px; }
    .form-group label { display: block; font-size: 12px; color: #64748b; margin-bottom: 4px; }
    .form-control { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #cbd5e1; font-size: 13px; }
    
    /* ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ãƒªã‚¹ãƒˆ */
    .radio-list {
        display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px;
    }
    .radio-item {
        display: flex; align-items: center; gap: 8px; font-size: 13px; cursor: pointer;
        padding: 4px 0;
    }
    .radio-item input { margin: 0; cursor: pointer; }

    /* ãƒ‡ãƒ¥ã‚¢ãƒ«ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ */
    .dual-slider-container { margin-top: 0; margin-bottom: 4px; }
    .dual-slider { position: relative; height: 24px; margin-top: 4px; margin-bottom: 0px; }
    .slider-track {
      position: absolute; top: 50%; transform: translateY(-50%);
      height: 6px; width: 100%; background: #e2e8f0; border-radius: 3px;
    }
    .slider-range {
      position: absolute; top: 50%; transform: translateY(-50%);
      height: 6px; background: #3b82f6; z-index: 1; border-radius: 3px;
    }
    .range-input {
      position: absolute; pointer-events: none; -webkit-appearance: none; z-index: 2;
      height: 24px; width: 100%; opacity: 0; cursor: pointer; margin: 0;
    }
    .range-input::-webkit-slider-thumb {
      pointer-events: auto; -webkit-appearance: none; width: 16px; height: 16px;
      border-radius: 50%; background: white; border: 2px solid #3b82f6; cursor: ew-resize;
    }
    .thumb {
      position: absolute; top: 50%; transform: translate(-50%, -50%);
      width: 12px; height: 12px; background: white;
      border: 2px solid #3b82f6; border-radius: 50%; z-index: 3;
      pointer-events: none; box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    .slider-value {
      font-size: 11px; font-weight: 500; color: #475569; font-family: monospace;
      display: flex; justify-content: space-between; margin-bottom: 0px;
    }

    /* PDFãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */
    .pdf-preview-box {
      background: #e2e8f0; border-radius: 6px; padding: 12px;
      display: flex; align-items: center; justify-content: center; min-height: 200px;
    }
    .pdf-page-preview { background: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: all 0.2s; }
    .pdf-page-preview.portrait { width: 120px; height: 170px; }
    .pdf-page-preview.landscape { width: 170px; height: 120px; }
    .pdf-grid-preview { display: grid; width: 100%; height: 100%; padding: 4px; gap: 2px; }
    .pdf-cell-preview { background: #f8fafc; overflow: hidden; display: flex; align-items: center; justify-content: center; }
    .pdf-cell-preview img { max-width: 100%; max-height: 100%; object-fit: contain; }

    /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ */
    .status-bar {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      background: #1e293b; color: white; padding: 10px 20px;
      border-radius: 30px; font-size: 13px; font-weight: 500;
      display: flex; align-items: center; gap: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100;
      opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    .status-bar.show { opacity: 1; }
    .spinner {
      width: 14px; height: 14px; border: 2px solid rgba(255,255,255,0.3);
      border-top-color: white; border-radius: 50%; animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Empty State */
    .empty-state {
      flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: #94a3b8; width: 100%; height: 100%; grid-column: 1 / -1;
    }
    .drop-message {
      border: 2px dashed #cbd5e1; border-radius: 12px; padding: 0;
      text-align: center; background: #f8fafc; transition: all 0.2s; cursor: pointer;
      width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;
      min-height: 300px;
    }
    .drop-message:hover { border-color: #3b82f6; background: #eff6ff; }
    
    /* å…¨ç”»é¢ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
    .drop-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(59, 130, 246, 0.1); border: 4px solid #3b82f6;
      z-index: 9999; display: none; pointer-events: none;
      justify-content: center; align-items: center;
    }
    .drop-overlay::after {
      content: 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã“ã“ã«ãƒ‰ãƒ­ãƒƒãƒ—';
      font-size: 24px; font-weight: bold; color: #3b82f6;
      background: white; padding: 20px 40px; border-radius: 12px;
      box-shadow: 0 10px 25px rgba(59, 130, 246, 0.2);
    }
    body.drag-over .drop-overlay { display: flex; }

    /* ãƒ¢ãƒ¼ãƒ€ãƒ«é¡ */
    .modal-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7); z-index: 200; display: none;
      align-items: center; justify-content: center;
    }
    .modal-overlay.active { display: flex; }
    .modal-content {
      background: white; width: 95%; max-width: 900px; max-height: 90vh;
      border-radius: 12px; overflow: hidden; display: flex; flex-direction: column;
    }
    .modal-body { 
      flex: 1; background: #0f172a; position: relative; overflow: hidden; 
      display: flex; justify-content: center; align-items: center;
      min-height: 400px;
    }
    /* Cropper.jsåˆæœŸåŒ–ç”¨ã®ç”»åƒã‚¹ã‚¿ã‚¤ãƒ« */
    .modal-body img { max-width: 100%; max-height: 100%; object-fit: contain; }
    .modal-body img.cropper-target { display: block; max-width: 100%; max-height: 100%; object-fit: unset; }

    
    /* èµ¤æ ã‚¨ãƒ‡ã‚£ã‚¿ç”¨ */
    #redBoxCanvas {
      position: absolute; top: 0; left: 0; cursor: crosshair;
    }
    .pick-cursor { cursor: crosshair; }
    .modal-instruction {
        position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
        background: rgba(0,0,0,0.7); color: white; padding: 8px 16px;
        border-radius: 20px; z-index: 10; pointer-events: none; font-size: 14px;
        white-space: nowrap;
    }
    
    /* æ‰‹å‹•ç·¨é›†ãƒ‘ãƒãƒ«ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«å†…ï¼‰ */
    .manual-controls {
      display: flex; gap: 8px; align-items: center; padding: 8px 16px; 
      background: #f8fafc; border-bottom: 1px solid #e2e8f0; font-size: 13px;
      flex-wrap: wrap;
    }
    .manual-input-group { display: flex; align-items: center; gap: 4px; }
    .manual-input { width: 60px; padding: 4px; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 12px; }
    .toggle-switch { display: flex; align-items: center; gap: 6px; cursor: pointer; user-select: none; }
  </style>
</head>
<body>

<!-- ãƒ‰ãƒ©ãƒƒã‚°ç”¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
<div class="drop-overlay"></div>

<header>
  <h1><i data-lucide="file-check"></i> ç”»åƒPDFçµåˆãƒ„ãƒ¼ãƒ«</h1>
  <span class="subtitle">è‡ªå‹•é»’æ¿ãƒˆãƒªãƒŸãƒ³ã‚°æ©Ÿèƒ½ä»˜ã</span>
</header>

<div class="app-layout">
  <!-- å·¦å´ï¼šãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
  <main class="main-content">
    <div class="toolbar">
      <button class="btn btn-secondary btn-sm" onclick="document.getElementById('folderInput').click()">
        <i data-lucide="folder-open" size="16"></i> ãƒ•ã‚©ãƒ«ãƒ€ã‚’é–‹ã
      </button>
      <input type="file" id="folderInput" webkitdirectory multiple accept="image/*" style="display:none">
      
      <button class="btn btn-secondary btn-sm" onclick="clearAll()">
        <i data-lucide="trash-2" size="16"></i> å…¨å‰Šé™¤
      </button>
      
      <div style="flex:1"></div>
      <span style="font-size:13px; color:#64748b;" id="countDisplay">0 æšã®ç”»åƒ</span>
    </div>

    <!-- ç”»åƒå‡¦ç†ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ (ã‚µã‚¤ãƒ‰ãƒãƒ¼ã‹ã‚‰ç§»å‹•) -->
    <div class="processing-toolbar">
      <div class="proc-group">
        <div class="proc-title"><i data-lucide="scissors" size="14"></i> ãƒˆãƒªãƒŸãƒ³ã‚°ãƒ»åŠ å·¥</div>
        <div class="proc-buttons">
          <button id="pickColorBtn" class="btn btn-purple btn-sm" disabled title="ç”»åƒã‹ã‚‰è‰²ã‚’å–å¾—">
            <i data-lucide="pipette" size="14"></i> ã‚¹ãƒã‚¤ãƒˆ
          </button>
          <button id="redBoxBtn" class="btn btn-red-outline btn-sm" disabled title="èµ¤æ ã¾ãŸã¯ãƒã‚¹ã‚¯ã‚’ä¸€æ‹¬è¨­å®š">
            <i data-lucide="square" size="14"></i> æ /ãƒã‚¹ã‚¯
          </button>
          <button id="autoCropBtn" class="btn btn-outline-success btn-sm" disabled title="ç¾åœ¨ã®ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼è¨­å®šã§å†å‡¦ç†">
            <i data-lucide="refresh-cw" size="14"></i> é©ç”¨
          </button>
          <button id="resetProcBtn" class="btn btn-secondary btn-sm" disabled onclick="resetAllProcessing()" title="ã™ã¹ã¦ã®å‡¦ç†ã‚’ãƒªã‚»ãƒƒãƒˆ">
            <i data-lucide="rotate-ccw" size="14"></i> ãƒªã‚»ãƒƒãƒˆ
          </button>
        </div>
      </div>
      
      <!-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼è¡¨ç¤ºåˆ‡æ›¿ãƒœã‚¿ãƒ³ -->
      <button id="toggleSlidersBtn" class="btn btn-secondary btn-sm" title="ãƒˆãƒªãƒŸãƒ³ã‚°æ„Ÿåº¦è¨­å®šã‚’è¡¨ç¤º">
        <i data-lucide="sliders-horizontal" size="14"></i> æ„Ÿåº¦èª¿æ•´
      </button>
    </div>

    <!-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ãƒ‘ãƒãƒ«ï¼ˆåˆæœŸçŠ¶æ…‹ã¯hiddenï¼‰ -->
    <div id="sliderPanel" class="slider-panel hidden">
      <div class="proc-sliders">
        <!-- Hue -->
        <div class="dual-slider-container">
          <div class="slider-value"><span>è‰²ç›¸(H)</span> <span id="val-h">35 - 90</span></div>
          <div class="dual-slider" id="slider-h">
            <div class="slider-track"></div><div class="slider-range"></div>
            <div class="thumb thumb-min"></div><div class="thumb thumb-max"></div>
            <input type="range" class="range-input input-min" min="0" max="180" value="35">
            <input type="range" class="range-input input-max" min="0" max="180" value="90">
          </div>
        </div>
        <!-- Sat -->
        <div class="dual-slider-container">
          <div class="slider-value"><span>å½©åº¦(S)</span> <span id="val-s">40 - 255</span></div>
          <div class="dual-slider" id="slider-s">
            <div class="slider-track"></div><div class="slider-range"></div>
            <div class="thumb thumb-min"></div><div class="thumb thumb-max"></div>
            <input type="range" class="range-input input-min" min="0" max="255" value="40">
            <input type="range" class="range-input input-max" min="0" max="255" value="255">
          </div>
        </div>
        <!-- Val -->
        <div class="dual-slider-container">
          <div class="slider-value"><span>æ˜åº¦(V)</span> <span id="val-v">40 - 255</span></div>
          <div class="dual-slider" id="slider-v">
            <div class="slider-track"></div><div class="slider-range"></div>
            <div class="thumb thumb-min"></div><div class="thumb thumb-max"></div>
            <input type="range" class="range-input input-min" min="0" max="255" value="40">
            <input type="range" class="range-input input-max" min="0" max="255" value="255">
          </div>
        </div>
      </div>
    </div>

    <div class="scroll-area">
      <div id="previewGrid" class="preview-grid is-empty"> <!-- Default to is-empty -->
        <div class="empty-state">
          <div class="drop-message" onclick="document.getElementById('folderInput').click()">
            <i data-lucide="image-plus" size="64" style="margin-bottom:16px; color:#cbd5e1"></i>
            <p style="font-size: 16px; font-weight: 500; color: #64748b;">
              ãƒ•ã‚©ãƒ«ãƒ€ã”ã¨ã“ã“ã«ãƒ‰ãƒ­ãƒƒãƒ—<br>
              <span style="font-size: 13px; font-weight: 400; color: #94a3b8;">ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ</span>
            </p>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- å³å´ï¼šã‚µã‚¤ãƒ‰ãƒãƒ¼ -->
  <aside class="sidebar">
    
    <!-- PDFä½œæˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³ -->
    <div class="sidebar-section">
      <div class="sidebar-title"><i data-lucide="file-output"></i> å‡ºåŠ›ã‚¢ã‚¯ã‚·ãƒ§ãƒ³</div>
      
      <div class="form-group" style="margin-bottom: 16px;">
        <label style="margin-bottom:8px;">å‡ºåŠ›ãƒ¢ãƒ¼ãƒ‰</label>
        <div class="radio-list">
          <label class="radio-item">
            <input type="radio" name="outputMode" value="pdf-image" checked>
            <span>PDF (ä¸­èº«ã‚’ç”»åƒåŒ–) <small style="color:#64748b; margin-left:4px;">æ¨å¥¨</small></span>
          </label>
          <label class="radio-item">
            <input type="radio" name="outputMode" value="pdf-text">
            <span>PDF (ãƒ†ã‚­ã‚¹ãƒˆä¿æŒ)</span>
          </label>
          <label class="radio-item">
            <input type="radio" name="outputMode" value="image-file">
            <span>ç”»åƒãƒ•ã‚¡ã‚¤ãƒ« (JPG/ZIP)</span>
          </label>
        </div>
      </div>

      <button id="generateBtn" class="btn btn-primary" disabled>
        <i data-lucide="download"></i> ä¿å­˜ã‚’å®Ÿè¡Œ
      </button>
    </div>

    <!-- PDFãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š -->
    <div class="sidebar-section">
      <div class="sidebar-title"><i data-lucide="settings-2"></i> ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š</div>
      <div class="form-group">
        <label>ç”¨ç´™ã‚µã‚¤ã‚º</label>
        <select id="pageSize" class="form-control">
          <option value="a4">A4</option>
          <option value="a3" selected>A3</option>
        </select>
      </div>
      <div class="form-group">
        <label>å‘ã</label>
        <select id="orientation" class="form-control">
          <option value="portrait">ç¸¦</option>
          <option value="landscape" selected>æ¨ª</option>
        </select>
      </div>
      <div class="form-group">
        <label>1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®æšæ•°</label>
        <select id="imagesPerPage" class="form-control">
          <option value="1">1æš</option>
          <option value="2">2æš</option>
          <option value="4" selected>4æš</option>
          <option value="6">6æš</option>
          <option value="9">9æš</option>
        </select>
      </div>
      <div class="form-group">
        <label>ä½™ç™½ (mm)</label>
        <input type="number" id="margin" value="10" min="0" max="50" class="form-control">
      </div>
    </div>

    <!-- PDFãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
    <div class="sidebar-section" style="border-bottom:none;">
      <div class="sidebar-title"><i data-lucide="eye"></i> ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç¢ºèª</div>
      <div class="pdf-preview-box">
        <div id="pdfPage" class="pdf-page-preview portrait"></div>
      </div>
    </div>
  </aside>
</div>

<!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ -->
<div id="statusBar" class="status-bar">
  <div class="spinner"></div><span id="statusText">å‡¦ç†ä¸­...</span>
</div>

<!-- ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼†æ“ä½œãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modal-overlay" id="previewModal">
  <div class="modal-content" style="max-width: 800px; max-height: 90vh;">
    <div style="padding:12px 16px; border-bottom:1px solid #e2e8f0; display:flex; justify-content:space-between; align-items:center;">
      <h3 style="font-size:16px; margin:0;" id="previewModalTitle">ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h3>
      <button onclick="closeModal('previewModal')" style="background:none; border:none; font-size:20px; cursor:pointer;">&times;</button>
    </div>
    <div class="modal-body" style="background: #0f172a; display: flex; align-items: center; justify-content: center;">
      <img id="previewModalImage" src="" alt="ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼" style="max-width: 100%; max-height: 60vh; object-fit: contain;">
    </div>
    <div style="padding:16px; border-top:1px solid #e2e8f0; display:flex; justify-content: space-between; align-items: center; background: #f8fafc;">
      <div>
        <button class="btn btn-danger" style="width: auto; padding: 8px 16px; font-size: 13px;" onclick="removeImageFromPreview()">
          <i data-lucide="trash-2" size="16"></i> å‰Šé™¤
        </button>
      </div>
      <div style="display: flex; gap: 8px;">
        <button id="previewUndoBtn" class="btn btn-secondary" style="width: auto; padding: 8px 16px; font-size: 13px;" onclick="undoEditFromPreview()">
          <i data-lucide="rotate-ccw" size="16"></i> å…ƒã«æˆ»ã™
        </button>
        <button class="btn btn-primary" style="width: auto; padding: 8px 16px; font-size: 13px;" onclick="openManualCropFromPreview()">
          <i data-lucide="scissors" size="16"></i> æ‰‹å‹•ãƒˆãƒªãƒŸãƒ³ã‚°
        </button>
        <button class="btn btn-secondary" style="width: auto; padding: 8px 16px; font-size: 13px;" onclick="closeModal('previewModal')">
          é–‰ã˜ã‚‹
        </button>
      </div>
    </div>
  </div>
</div>


<!-- ãƒˆãƒªãƒŸãƒ³ã‚°ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modal-overlay" id="cropModal">
  <div class="modal-content">
    <div style="padding:16px; border-bottom:1px solid #e2e8f0; display:flex; justify-content:space-between;">
      <h3 style="font-size:16px; margin:0;">æ‰‹å‹•ãƒˆãƒªãƒŸãƒ³ã‚°</h3>
      <button onclick="closeModal('cropModal')" style="background:none; border:none; font-size:20px; cursor:pointer;">&times;</button>
    </div>
    <div class="modal-body">
      <!-- Cropperã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã¯å°‚ç”¨ã®ã‚¯ãƒ©ã‚¹ã‚’ä»˜ä¸ -->
      <img id="cropTarget" src="" alt="" class="cropper-target">
    </div>
    <div style="padding:16px; border-top:1px solid #e2e8f0; display:flex; justify-content:flex-end; gap:12px;">
      <button class="btn btn-secondary" style="width:auto;" onclick="closeModal('cropModal')">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      <button class="btn btn-primary" style="width:auto;" onclick="applyManualCrop()">é©ç”¨</button>
    </div>
  </div>
</div>

<!-- ã‚¹ãƒã‚¤ãƒˆç”¨ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modal-overlay" id="pickModal">
  <div class="modal-content">
    <div style="padding:16px; border-bottom:1px solid #e2e8f0; display:flex; justify-content:space-between;">
      <h3 style="font-size:16px; margin:0;">ğŸ¨ é»’æ¿ã®è‰²ã‚’é¸æŠ</h3>
    </div>
    <div class="modal-body">
      <div class="modal-instruction">é»’æ¿ã®éƒ¨åˆ†ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„</div>
      <div class="img-container pick-cursor" style="height:100%; width:100%; display:flex; align-items:center; justify-content:center;">
        <img id="pickImage" src="" alt="è‰²é¸æŠ">
      </div>
    </div>
    <div style="padding:16px; border-top:1px solid #e2e8f0; display:flex; justify-content:flex-end; gap:12px;">
      <button class="btn btn-secondary" onclick="closePickModalAndRun(false)">ã‚¹ã‚­ãƒƒãƒ—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã§å®Ÿè¡Œï¼‰</button>
    </div>
  </div>
</div>

<!-- èµ¤æ ç·¨é›†ç”¨ãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆæ©Ÿèƒ½æ‹¡å¼µç‰ˆï¼‰ -->
<div class="modal-overlay" id="redBoxModal">
  <div class="modal-content" style="max-width:1000px; height:90vh;">
    <div style="padding:16px; border-bottom:1px solid #e2e8f0; display:flex; justify-content:space-between; align-items:center;">
      <h3 style="font-size:16px; margin:0;">ğŸ”´ æ ã®ä¸€æ‹¬è¿½åŠ è¨­å®šï¼ˆ1æšç›®ã§æŒ‡å®šï¼‰</h3>
      <button class="btn btn-secondary" style="width:auto; padding:4px 8px; font-size:12px;" onclick="clearRedBoxes()">
        <i data-lucide="trash"></i> æ ã‚’å…¨æ¶ˆå»
      </button>
    </div>
    
    <!-- æ‰‹å‹•ç·¨é›†ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ -->
    <div class="manual-controls">
      <div style="margin-right:16px; display:flex; gap:12px; align-items:center;">
        <label class="toggle-switch" title="æ å¤–ã‚’è‰²ã§å¡—ã‚Šã¤ã¶ã—ã¾ã™">
          <input type="checkbox" id="maskModeCheck" checked> <!-- Default Checked -->
          <span>æ å¤–ã‚’å¡—ã‚Šã¤ã¶ã™ (ãƒã‚¹ã‚¯)</span>
        </label>
        <div style="display:flex; align-items:center; gap:4px;">
           <span>è‰²:</span>
           <input type="color" id="maskColorInput" value="#ffffff" style="border:none; width:24px; height:24px; cursor:pointer;">
        </div>
      </div>
      <div style="width:1px; height:20px; background:#e2e8f0; margin:0 8px;"></div>
      <div class="manual-input-group">
        <span>X:</span><input type="number" id="rbX" class="manual-input" min="0">
        <span>Y:</span><input type="number" id="rbY" class="manual-input" min="0">
        <span>W:</span><input type="number" id="rbW" class="manual-input" min="0">
        <span>H:</span><input type="number" id="rbH" class="manual-input" min="0">
        <button onclick="updateRedBoxFromInputs()" class="btn btn-secondary" style="width:auto; padding:4px 8px; margin:0 0 0 4px; font-size:12px;">æ›´æ–°</button>
      </div>
    </div>

    <div class="modal-body" id="redBoxBody" style="background:#333; overflow:hidden;">
      <div class="modal-instruction">ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦æ ã‚’è¿½åŠ  (Ctrl+Zã§æˆ»ã‚‹)</div>
      <!-- ç”»åƒã¨Canvasã‚’é‡ã­ã‚‹ã‚³ãƒ³ãƒ†ãƒŠ -->
      <div style="position:relative; display:inline-block;" id="redBoxContainer">
        <img id="redBoxTargetImage" style="display:block; max-width:100%; max-height:80vh; pointer-events:none;">
        <canvas id="redBoxCanvas" style="position:absolute; top:0; left:0;"></canvas>
      </div>
    </div>
    <div style="padding:16px; border-top:1px solid #e2e8f0; display:flex; justify-content:flex-end; gap:12px;">
      <button class="btn btn-secondary" style="width:auto;" onclick="closeModal('redBoxModal')">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      <button class="btn btn-primary" style="width:auto;" onclick="applyRedBoxesToAll()">å…¨ç”»åƒã«é©ç”¨</button>
    </div>
  </div>
</div>

<script>
  // åˆæœŸåŒ–
  lucide.createIcons();
  
  // çŠ¶æ…‹ç®¡ç†
  let images = [];
  let cropper = null;
  let currentEditIndex = null;
  let currentPreviewIndex = null; // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­ã®ç”»åƒã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  let isOpenCvReady = false;
  
  // èµ¤æ ãƒ»ãƒã‚¹ã‚¯è¨­å®š
  let redBoxes = []; // {x, y, w, h} (relative 0-1)
  let redBoxConfig = {
    isMaskMode: true, // Default to true
    maskColor: '#ffffff'
  };
  
  // â˜…è¿½åŠ : ãƒˆãƒªãƒŸãƒ³ã‚°æ™‚ã®ã‚¢ãƒƒãƒ—ã‚¹ã‚±ãƒ¼ãƒ«å€ç‡ (2 -> 3)
  const CROP_SCALE = 3;

  // è¦ç´ å–å¾—
  const els = {
    folderInput: document.getElementById('folderInput'),
    previewGrid: document.getElementById('previewGrid'),
    generateBtn: document.getElementById('generateBtn'),
    autoCropBtn: document.getElementById('autoCropBtn'),
    pickColorBtn: document.getElementById('pickColorBtn'),
    redBoxBtn: document.getElementById('redBoxBtn'),
    resetProcBtn: document.getElementById('resetProcBtn'),
    countDisplay: document.getElementById('countDisplay'),
    statusBar: document.getElementById('statusBar'),
    statusText: document.getElementById('statusText'),
    pdfPage: document.getElementById('pdfPage'),
    cropModal: document.getElementById('cropModal'),
    cropTarget: document.getElementById('cropTarget'),
    pickModal: document.getElementById('pickModal'),
    pickImage: document.getElementById('pickImage'),
    redBoxModal: document.getElementById('redBoxModal'),
    redBoxTargetImage: document.getElementById('redBoxTargetImage'),
    redBoxCanvas: document.getElementById('redBoxCanvas'),
    
    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ãƒ‘ãƒãƒ«å‘¨ã‚Š
    toggleSlidersBtn: document.getElementById('toggleSlidersBtn'),
    sliderPanel: document.getElementById('sliderPanel'),
    
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨
    previewModal: document.getElementById('previewModal'),
    previewModalTitle: document.getElementById('previewModalTitle'),
    previewModalImage: document.getElementById('previewModalImage'),
    previewUndoBtn: document.getElementById('previewUndoBtn'),

    // èµ¤æ ãƒ„ãƒ¼ãƒ«ãƒãƒ¼
    maskModeCheck: document.getElementById('maskModeCheck'),
    maskColorInput: document.getElementById('maskColorInput'),
    rbX: document.getElementById('rbX'),
    rbY: document.getElementById('rbY'),
    rbW: document.getElementById('rbW'),
    rbH: document.getElementById('rbH'),
    
    // è¨­å®š
    pageSize: document.getElementById('pageSize'),
    orientation: document.getElementById('orientation'),
    imagesPerPage: document.getElementById('imagesPerPage'),
    margin: document.getElementById('margin'),
  };

  // OpenCVèª­ã¿è¾¼ã¿å®Œäº†ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
  function onOpenCvReady() {
    isOpenCvReady = true;
    console.log("OpenCV Ready");
    updateButtonStates();
  }

  function updateButtonStates() {
    const hasImages = images.length > 0;
    const ready = isOpenCvReady && hasImages;
    els.autoCropBtn.disabled = !ready;
    els.pickColorBtn.disabled = !ready;
    els.redBoxBtn.disabled = !hasImages; // ç”»åƒãŒã‚ã‚Œã°æ è¨­å®šã¯å¯èƒ½
    els.generateBtn.disabled = !hasImages;
    els.resetProcBtn.disabled = !hasImages;
  }

  // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒˆã‚°ãƒ«æ©Ÿèƒ½
  els.toggleSlidersBtn.onclick = () => {
    els.sliderPanel.classList.toggle('hidden');
    els.toggleSlidersBtn.classList.toggle('active');
  };

  // --- ãƒ‡ãƒ¥ã‚¢ãƒ«ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ---
  function setupDualSlider(id, minVal, maxVal, maxLimit) {
    const container = document.getElementById(id);
    const range = container.querySelector('.slider-range');
    const thumbMin = container.querySelector('.thumb-min');
    const thumbMax = container.querySelector('.thumb-max');
    const inputMin = container.querySelector('.input-min');
    const inputMax = container.querySelector('.input-max');
    const display = document.getElementById(id.replace('slider', 'val'));

    function update() {
      let v1 = parseInt(inputMin.value);
      let v2 = parseInt(inputMax.value);
      if (v1 > v2) { [v1, v2] = [v2, v1]; } 
      const p1 = (v1 / maxLimit) * 100;
      const p2 = (v2 / maxLimit) * 100;
      range.style.left = p1 + '%';
      range.style.width = (p2 - p1) + '%';
      thumbMin.style.left = p1 + '%';
      thumbMax.style.left = p2 + '%';
      display.textContent = `${v1} - ${v2}`;
    }
    inputMin.addEventListener('input', () => {
      if(parseInt(inputMin.value) > parseInt(inputMax.value)) inputMin.value = inputMax.value;
      update();
    });
    inputMax.addEventListener('input', () => {
      if(parseInt(inputMax.value) < parseInt(inputMin.value)) inputMax.value = inputMin.value;
      update();
    });
    container.setValues = (v1, v2) => {
      inputMin.value = v1; inputMax.value = v2; update();
    };
    update();
  }

  setupDualSlider('slider-h', 35, 90, 180);
  setupDualSlider('slider-s', 40, 255, 255);
  setupDualSlider('slider-v', 40, 255, 255);

  function getHSVSettings() {
    const getVal = (id) => {
      const c = document.getElementById(id);
      return [parseInt(c.querySelector('.input-min').value), parseInt(c.querySelector('.input-max').value)];
    }
    const h = getVal('slider-h');
    const s = getVal('slider-s');
    const v = getVal('slider-v');
    return { lower: [h[0], s[0], v[0], 0], upper: [h[1], s[1], v[1], 0] };
  }

  // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
  els.folderInput.addEventListener('change', async (e) => {
    await handleFiles(e.target.files);
    e.target.value = '';
  });

  // å…¨ç”»é¢ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—
  const dragEvents = ['dragenter', 'dragover', 'dragleave', 'drop'];
  dragEvents.forEach(eventName => document.body.addEventListener(eventName, e => { e.preventDefault(); e.stopPropagation(); }, false));
  document.body.addEventListener('dragenter', () => document.body.classList.add('drag-over'));
  document.body.addEventListener('dragover', () => document.body.classList.add('drag-over'));
  document.body.addEventListener('dragleave', (e) => { if (e.relatedTarget === null) document.body.classList.remove('drag-over'); });
  document.body.addEventListener('drop', async (e) => {
    document.body.classList.remove('drag-over');
    const items = e.dataTransfer.items;
    let fileList = [];
    if (items) {
      for (let i = 0; i < items.length; i++) {
        const item = items[i].webkitGetAsEntry ? items[i].webkitGetAsEntry() : null;
        if (item) { await scanFiles(item, fileList); } 
        else { const file = items[i].getAsFile(); if (file && file.type.startsWith('image/')) fileList.push(file); }
      }
    } else {
      fileList = [...e.dataTransfer.files].filter(f => f.type.startsWith('image/'));
    }
    await handleFiles(fileList);
  });

  async function scanFiles(item, fileList) {
    if (item.isFile) {
      return new Promise(resolve => item.file(file => {
        if (file.type.startsWith('image/') || /\.(jpe?g|png|gif|bmp|webp)$/i.test(file.name)) fileList.push(file);
        resolve();
      }));
    } else if (item.isDirectory) {
      const dirReader = item.createReader();
      const entries = await readAllEntries(dirReader);
      for (const entry of entries) await scanFiles(entry, fileList);
    }
  }
  function readAllEntries(dirReader) {
    return new Promise(resolve => {
      let entries = [];
      const read = () => {
        dirReader.readEntries(result => {
          if (!result.length) resolve(entries);
          else { entries = entries.concat(result); read(); }
        });
      };
      read();
    });
  }

  ['pageSize', 'orientation', 'imagesPerPage', 'margin'].forEach(id => els[id].addEventListener('change', updatePdfPreview));

  els.autoCropBtn.onclick = runAutoCropForce;
  els.pickColorBtn.onclick = () => { if(images.length > 0) openPickModal(images[0]); };
  els.generateBtn.onclick = generateOutput; 
  els.pickImage.onclick = (e) => handleColorPick(e.target, e.offsetX, e.offsetY, true);
  els.redBoxBtn.onclick = openRedBoxEditor;

  // èµ¤æ è¨­å®šç”¨ã‚¤ãƒ™ãƒ³ãƒˆ
  els.maskModeCheck.addEventListener('change', (e) => {
    redBoxConfig.isMaskMode = e.target.checked;
    drawRedBoxesOnCanvas();
  });
  els.maskColorInput.addEventListener('input', (e) => {
    redBoxConfig.maskColor = e.target.value;
    if(redBoxConfig.isMaskMode) drawRedBoxesOnCanvas();
  });


  // ã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆCtrl+Zï¼‰
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key === 'z') {
      if (els.redBoxModal.classList.contains('active')) {
        e.preventDefault();
        undoLastRedBox();
      }
    }
  });

  // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–å´ï¼ˆèƒŒæ™¯ï¼‰ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
  document.querySelectorAll('.modal-overlay').forEach(overlay => {
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        closeModal(overlay.id);
      }
    });
  });

  function undoLastRedBox() {
    if (redBoxes.length > 0) {
      redBoxes.pop();
      drawRedBoxesOnCanvas();
      updateInputsFromLastBox();
    }
  }

  // --- ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ ---
  async function handleFiles(fileList) {
    if (fileList.length === 0) return;
    showStatus(true, 'ç”»åƒã‚’èª­ã¿è¾¼ã¿ä¸­...');
    
    const newFiles = Array.from(fileList).sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));
    for (const file of newFiles) {
      const dataUrl = await readFile(file);
      images.push({
        file, name: file.name,
        dataUrl: dataUrl,
        croppedUrl: dataUrl, // ãƒˆãƒªãƒŸãƒ³ã‚°å¾Œã®ãƒ™ãƒ¼ã‚¹ç”»åƒ
        originalUrl: dataUrl, // å®Œå…¨ãªã‚ªãƒªã‚¸ãƒŠãƒ«
        isEdited: false,
        detectRect: null // æ¤œå‡ºã•ã‚ŒãŸçŸ©å½¢
      });
    }
    renderGrid();
    updatePdfPreview();
    updateButtonStates();
    
    if (isOpenCvReady) {
      if (images.length > 0) openPickModal(images[0]);
      else showStatus(false);
    } else {
      showStatus(true, 'ç”»åƒå‡¦ç†ã‚¨ãƒ³ã‚¸ãƒ³æº–å‚™ä¸­...');
    }
  }

  function readFile(file) {
    return new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = e => resolve(e.target.result);
      reader.readAsDataURL(file);
    });
  }

  function renderGrid() {
    els.countDisplay.textContent = `${images.length} æšã®ç”»åƒ`;
    const grid = els.previewGrid;
    
    // ç”»åƒãŒãªã„å ´åˆï¼šå…¨ç”»é¢Flexè¡¨ç¤ºã«åˆ‡ã‚Šæ›¿ãˆ
    if (images.length === 0) {
      grid.classList.add('is-empty');
      grid.innerHTML = `
        <div class="empty-state">
          <div class="drop-message" onclick="document.getElementById('folderInput').click()">
            <i data-lucide="image-plus" size="64" style="margin-bottom:16px; color:#cbd5e1"></i>
            <p style="font-size: 16px; font-weight: 500; color: #64748b;">ãƒ•ã‚©ãƒ«ãƒ€ã”ã¨ã“ã“ã«ãƒ‰ãƒ­ãƒƒãƒ—<br><span style="font-size: 13px; font-weight: 400; color: #94a3b8;">ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ</span></p>
          </div>
        </div>`;
      updateButtonStates();
      lucide.createIcons();
      return;
    }
    
    // ç”»åƒãŒã‚ã‚‹å ´åˆï¼šGridè¡¨ç¤ºã«åˆ‡ã‚Šæ›¿ãˆ
    grid.classList.remove('is-empty');
    updateButtonStates();
    
    // ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆï¼ˆã‚¯ãƒªãƒƒã‚¯ã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’é–‹ãï¼‰
    grid.innerHTML = images.map((img, i) => `
      <div class="preview-item" draggable="true" data-index="${i}" onclick="openPreviewModal(${i})">
        <div class="index">${i+1}</div>
        <div class="img-wrapper"><img src="${img.dataUrl}" data-index="${i}"></div>
        <div class="filename">${img.name}</div>
      </div>
    `).join('');
    lucide.createIcons();
    setupDragAndDrop();
  }

  // --- ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«æ©Ÿèƒ½ ---
  window.openPreviewModal = (index) => {
    currentPreviewIndex = index;
    const img = images[index];
    els.previewModalTitle.textContent = img.name;
    els.previewModalImage.src = img.dataUrl;
    
    // ã€Œå…ƒã«æˆ»ã™ã€ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºåˆ¶å¾¡
    els.previewUndoBtn.style.display = img.isEdited ? 'inline-flex' : 'none';
    
    els.previewModal.classList.add('active');
  };

  window.openManualCropFromPreview = () => {
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã¦ã‹ã‚‰ãƒˆãƒªãƒŸãƒ³ã‚°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
    els.previewModal.classList.remove('active');
    setTimeout(() => {
        openManualCrop(currentPreviewIndex);
    }, 100);
  };
  
  window.undoEditFromPreview = async () => {
     await undoEdit(currentPreviewIndex);
     // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»åƒã‚’æ›´æ–°
     els.previewModalImage.src = images[currentPreviewIndex].dataUrl;
     els.previewUndoBtn.style.display = 'none';
  };

  window.removeImageFromPreview = () => {
      // å‰Šé™¤å®Ÿè¡Œ
      removeImage(currentPreviewIndex);
      // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
      els.previewModal.classList.remove('active');
  };


  // --- è‰²æŒ‡å®šãƒ»è‡ªå‹•ã‚¯ãƒ­ãƒƒãƒ— ---
  function openPickModal(image) {
      els.pickImage.src = image.originalUrl;
      els.pickModal.classList.add('active');
      showStatus(false);
  }
  function closePickModalAndRun(shouldRunCrop) {
      els.pickModal.classList.remove('active');
      showStatus(true, 'è‡ªå‹•ãƒˆãƒªãƒŸãƒ³ã‚°ä¸­...');
      setTimeout(() => { runAutoCrop(true); }, 100);
  }

  async function runAutoCrop(skipEdited = true) {
    if (!isOpenCvReady) return;
    const settings = getHSVSettings();
    for (let i = 0; i < images.length; i++) {
      if (skipEdited && images[i].isEdited) continue;
      const resultObj = await detectGreenBoard(images[i].originalUrl, settings);
      if (resultObj) {
        images[i].croppedUrl = resultObj.url; 
        images[i].dataUrl = resultObj.url;
        images[i].detectRect = resultObj.rect; // çŸ©å½¢ã‚’ä¿å­˜
        images[i].isEdited = true;
      }
    }
    // èµ¤æ è¨­å®šãŒã‚ã‚‹å ´åˆã¯é©ç”¨
    if(redBoxes.length > 0) {
      await applyRedBoxesInternal();
    }
    
    renderGrid();
    updatePdfPreview();
    showStatus(false);
    
    // ãƒˆãƒªãƒŸãƒ³ã‚°å®Œäº†å¾Œã€è‡ªå‹•ã§èµ¤æ ã‚¨ãƒ‡ã‚£ã‚¿ã‚’é–‹ã
    if(images.length > 0 && !els.redBoxModal.classList.contains('active')) {
       openRedBoxEditor();
    }
  }

  async function runAutoCropForce() {
    if (!isOpenCvReady) return;
    showStatus(true, 'å…¨ç”»åƒã‚’å†å‡¦ç†ä¸­...');
    await new Promise(r => setTimeout(r, 50));
    images.forEach(img => {
      img.dataUrl = img.originalUrl;
      img.croppedUrl = img.originalUrl;
      img.detectRect = null;
      img.isEdited = false;
    });
    await runAutoCrop(false); 
  }

  function detectGreenBoard(url, hsvRange) {
    return new Promise(resolve => {
      const img = new Image();
      img.onload = () => {
        try {
          const cv = window.cv;
          const canvas = document.createElement('canvas');
          canvas.width = img.width; canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          let src = cv.imread(canvas);
          let hsv = new cv.Mat();
          cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
          cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
          let low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), hsvRange.lower);
          let high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), hsvRange.upper);
          let mask = new cv.Mat();
          cv.inRange(hsv, low, high, mask);
          let kernel = cv.Mat.ones(5, 5, cv.CV_8U);
          cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);
          cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernel);
          let contours = new cv.MatVector();
          let hierarchy = new cv.Mat();
          cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
          let bestRect = null; let maxScore = 0;
          const minArea = (src.cols * src.rows) * 0.01;
          for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            if (area < minArea) continue;
            let rect = cv.boundingRect(cnt);
            if (area > maxScore) { maxScore = area; bestRect = rect; }
          }
          let res = null;
          if (bestRect) {
            const cCanvas = document.createElement('canvas');
            // ä¿®æ­£: ã‚¢ãƒƒãƒ—ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨ (CROP_SCALE)
            cCanvas.width = bestRect.width * CROP_SCALE; 
            cCanvas.height = bestRect.height * CROP_SCALE;
            const cCtx = cCanvas.getContext('2d');
            // ç”»è³ªè¨­å®š
            cCtx.imageSmoothingEnabled = true;
            cCtx.imageSmoothingQuality = 'high';
            cCtx.drawImage(img, bestRect.x, bestRect.y, bestRect.width, bestRect.height, 0, 0, cCanvas.width, cCanvas.height);
            res = { url: cCanvas.toDataURL('image/jpeg', 0.95), rect: bestRect };
          }
          src.delete(); hsv.delete(); mask.delete(); low.delete(); high.delete(); kernel.delete(); contours.delete(); hierarchy.delete();
          resolve(res);
        } catch(e) { console.error(e); resolve(null); }
      };
      img.src = url;
    });
  }

  // --- èµ¤æ ã‚¨ãƒ‡ã‚£ã‚¿ (Canvasæ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ã®æ”¹å–„) ---
  let isDrawingRedBox = false;
  let startX, startY;
  
  // ãƒªã‚µã‚¤ã‚ºç›£è¦–ç”¨ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼
  const redBoxResizeObserver = new ResizeObserver(entries => {
    for (const entry of entries) {
      if (entry.target === els.redBoxTargetImage) {
        // ç”»åƒã‚µã‚¤ã‚ºãŒå¤‰ã‚ã£ãŸã‚‰Canvasã‚‚åˆã‚ã›ã‚‹
        fitRedBoxCanvasToImage();
      }
    }
  });

  function fitRedBoxCanvasToImage() {
    const img = els.redBoxTargetImage;
    const canvas = els.redBoxCanvas;
    
    // è¡¨ç¤ºã‚µã‚¤ã‚ºãŒ0ãªã‚‰ä½•ã‚‚ã—ãªã„
    if(img.clientWidth === 0 || img.clientHeight === 0) return;

    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚µã‚¤ã‚ºã‚’è¡¨ç¤ºã‚µã‚¤ã‚ºï¼ˆclientWidth/Heightï¼‰ã«åˆã‚ã›ã‚‹
    // ã“ã‚Œã«ã‚ˆã‚Šã€åº§æ¨™è¨ˆç®—ã‚’å¸¸ã«è¡¨ç¤ºãƒ”ã‚¯ã‚»ãƒ«ãƒ™ãƒ¼ã‚¹ã§è¡Œãˆã‚‹
    canvas.width = img.clientWidth;
    canvas.height = img.clientHeight;
    
    // ã‚¹ã‚¿ã‚¤ãƒ«ã‚‚ä¸€è‡´ã•ã›ã‚‹ï¼ˆå¿µã®ãŸã‚ï¼‰
    canvas.style.width = img.clientWidth + 'px';
    canvas.style.height = img.clientHeight + 'px';
    
    drawRedBoxesOnCanvas();
  }

  function openRedBoxEditor() {
    if(images.length === 0) return;
    const targetImg = images[0];
    
    els.redBoxTargetImage.onload = () => {
      // ç”»åƒãƒ­ãƒ¼ãƒ‰å¾Œã«ãƒªã‚µã‚¤ã‚ºç›£è¦–é–‹å§‹
      redBoxResizeObserver.observe(els.redBoxTargetImage);
      fitRedBoxCanvasToImage();
      updateInputsFromLastBox();
    };
    els.redBoxTargetImage.src = targetImg.croppedUrl; 
    els.redBoxModal.classList.add('active');
  }

  function initRedBoxCanvas() {
     // ãƒªã‚µã‚¤ã‚ºã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã§ç®¡ç†ã™ã‚‹ãŸã‚ã€åˆæœŸåŒ–å‡¦ç†ã¯å®Ÿè³ª fitRedBoxCanvasToImage ã«å§”è­²
     // ã“ã“ã§ã¯ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ç™»éŒ²ã®ã¿è¡Œã†
     
     const canvas = els.redBoxCanvas;

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (Canvasä¸Šã§ã®ãƒ‰ãƒ©ãƒƒã‚°)
    canvas.onmousedown = (e) => {
      isDrawingRedBox = true;
      const rect = canvas.getBoundingClientRect();
      // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®å†…éƒ¨è§£åƒåº¦ã¨è¡¨ç¤ºã‚µã‚¤ã‚ºãŒä¸€è‡´ã—ã¦ã„ã‚‹ã®ã§scaleã¯1
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
    };

    canvas.onmousemove = (e) => {
      if(!isDrawingRedBox) return;
      const rect = canvas.getBoundingClientRect();
      const currentX = e.clientX - rect.left;
      const currentY = e.clientY - rect.top;
      
      drawRedBoxesOnCanvas(); // æ—¢å­˜æç”»
      
      // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®æ æç”»
      const ctx = canvas.getContext('2d');
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 4;
      ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
      
      // å…¥åŠ›å€¤ã‚‚ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°
      els.rbX.value = Math.round(Math.min(startX, currentX));
      els.rbY.value = Math.round(Math.min(startY, currentY));
      els.rbW.value = Math.round(Math.abs(currentX - startX));
      els.rbH.value = Math.round(Math.abs(currentY - startY));
    };

    canvas.onmouseup = (e) => {
      if(!isDrawingRedBox) return;
      isDrawingRedBox = false;
      const rect = canvas.getBoundingClientRect();
      const endX = e.clientX - rect.left;
      const endY = e.clientY - rect.top;
      
      const w = Math.abs(endX - startX);
      const h = Math.abs(endY - startY);
      
      if(w > 5 && h > 5) {
        const box = {
          x: Math.min(startX, endX) / canvas.width,
          y: Math.min(startY, endY) / canvas.height,
          w: w / canvas.width,
          h: h / canvas.height
        };
        redBoxes.push(box);
      }
      drawRedBoxesOnCanvas();
      updateInputsFromLastBox();
    };
  }
  
  // åˆå›ã®ã¿ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ²
  initRedBoxCanvas();


  function updateInputsFromLastBox() {
    if(redBoxes.length > 0) {
      const last = redBoxes[redBoxes.length - 1];
      const w = els.redBoxCanvas.width;
      const h = els.redBoxCanvas.height;
      els.rbX.value = Math.round(last.x * w);
      els.rbY.value = Math.round(last.y * h);
      els.rbW.value = Math.round(last.w * w);
      els.rbH.value = Math.round(last.h * h);
    } else {
      els.rbX.value = 0; els.rbY.value = 0; els.rbW.value = 0; els.rbH.value = 0;
    }
  }

  // æ‰‹å‹•å…¥åŠ›å€¤ã®åæ˜ 
  window.updateRedBoxFromInputs = () => {
    if(redBoxes.length === 0) {
       // æ–°è¦ä½œæˆ
       redBoxes.push({x:0, y:0, w:0, h:0}); 
    }
    const last = redBoxes[redBoxes.length - 1];
    const w = els.redBoxCanvas.width;
    const h = els.redBoxCanvas.height;
    
    const inputX = parseInt(els.rbX.value) || 0;
    const inputY = parseInt(els.rbY.value) || 0;
    const inputW = parseInt(els.rbW.value) || 0;
    const inputH = parseInt(els.rbH.value) || 0;

    last.x = inputX / w;
    last.y = inputY / h;
    last.w = inputW / w;
    last.h = inputH / h;

    drawRedBoxesOnCanvas();
  };

  function drawRedBoxesOnCanvas() {
    const canvas = els.redBoxCanvas;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ãƒã‚¹ã‚¯ãƒ¢ãƒ¼ãƒ‰ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
    if (redBoxConfig.isMaskMode) {
      ctx.fillStyle = redBoxConfig.maskColor + '80'; // åŠé€æ˜ã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
      // å…¨ä½“ã‚’å¡—ã‚‹
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // æ å†…ã‚’åˆ‡ã‚ŠæŠœãï¼ˆé€æ˜ã«ã™ã‚‹ï¼‰
      ctx.globalCompositeOperation = 'destination-out';
      redBoxes.forEach(box => {
        ctx.fillRect(
          box.x * canvas.width,
          box.y * canvas.height,
          box.w * canvas.width,
          box.h * canvas.height
        );
      });
      ctx.globalCompositeOperation = 'source-over';
    }

    // æ ç·šã®æç”» (å¸¸ã«è¡¨ç¤ºã—ã¦ç¯„å›²ã‚’ã‚ã‹ã‚Šã‚„ã™ã)
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 4;
    redBoxes.forEach(box => {
      ctx.strokeRect(
        box.x * canvas.width,
        box.y * canvas.height,
        box.w * canvas.width,
        box.h * canvas.height
      );
    });
  }

  function clearRedBoxes() {
    redBoxes = [];
    drawRedBoxesOnCanvas();
    updateInputsFromLastBox();
  }

  async function applyRedBoxesToAll() {
    showStatus(true, 'æ è¨­å®šã‚’é©ç”¨ä¸­...');
    redBoxResizeObserver.unobserve(els.redBoxTargetImage); // ç›£è¦–åœæ­¢
    await applyRedBoxesInternal();
    renderGrid();
    updatePdfPreview();
    closeModal('redBoxModal');
    showStatus(false);
  }

  // å†…éƒ¨å‡¦ç†ç”¨
  async function applyRedBoxesInternal() {
    if(redBoxes.length === 0) return;

    for (let i = 0; i < images.length; i++) {
      const baseImgUrl = images[i].croppedUrl;
      const resultUrl = await drawRedBoxesOnImage(baseImgUrl);
      images[i].dataUrl = resultUrl;
    }
  }

  function drawRedBoxesOnImage(url) {
    return new Promise(resolve => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        
        if (redBoxConfig.isMaskMode) {
           // ãƒã‚¹ã‚¯ãƒ¢ãƒ¼ãƒ‰: å…¨ä½“ã‚’å¡—ã‚Šã¤ã¶ã—ã€æ å†…ã ã‘ç”»åƒã‚’è¡¨ç¤º
           
           // åˆ¥ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ãƒã‚¹ã‚¯ã‚’ä½œæˆ
           const maskCanvas = document.createElement('canvas');
           maskCanvas.width = img.width;
           maskCanvas.height = img.height;
           const mCtx = maskCanvas.getContext('2d');
           
           // æŒ‡å®šè‰²ã§å¡—ã‚Šã¤ã¶ã—
           mCtx.fillStyle = redBoxConfig.maskColor;
           mCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
           
           // æ ã®éƒ¨åˆ†ã‚’é€æ˜ã«ãã‚ŠæŠœã
           mCtx.globalCompositeOperation = 'destination-out';
           redBoxes.forEach(box => {
              mCtx.fillRect(
                box.x * canvas.width,
                box.y * canvas.height,
                box.w * canvas.width,
                box.h * canvas.height
              );
           });
           
           // å…ƒç”»åƒã®ä¸Šã«ãƒã‚¹ã‚¯ã‚’é‡ã­ã‚‹
           ctx.drawImage(maskCanvas, 0, 0);

        } else {
           // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰: èµ¤æ ç·šã‚’æç”»
           ctx.strokeStyle = 'red';
           ctx.lineWidth = Math.max(3, img.width * 0.005); 
           redBoxes.forEach(box => {
             ctx.strokeRect(
               box.x * canvas.width,
               box.y * canvas.height,
               box.w * canvas.width,
               box.h * canvas.height
             );
           });
        }
        resolve(canvas.toDataURL('image/jpeg', 0.95));
      };
      img.src = url;
    });
  }

  // --- ã‚¹ãƒã‚¤ãƒˆæ©Ÿèƒ½ ---
  function handleColorPick(img, offsetX, offsetY, isModal) {
    const rect = img.getBoundingClientRect();
    const naturalRatio = img.naturalWidth / img.naturalHeight;
    const displayRatio = rect.width / rect.height;
    let drawW, drawH, startX, startY;
    if (naturalRatio > displayRatio) {
      drawW = rect.width; drawH = rect.width / naturalRatio;
      startX = 0; startY = (rect.height - drawH) / 2;
    } else {
      drawH = rect.height; drawW = rect.height * naturalRatio;
      startX = (rect.width - drawW) / 2; startY = 0;
    }
    let clickX = offsetX - startX; let clickY = offsetY - startY;
    if (clickX < 0 || clickX > drawW || clickY < 0 || clickY > drawH) return;
    const scale = img.naturalWidth / drawW;
    const srcX = clickX * scale; const srcY = clickY * scale;
    const canvas = document.createElement('canvas');
    canvas.width = 1; canvas.height = 1;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, srcX, srcY, 1, 1, 0, 0, 1, 1);
    const [r, g, b] = ctx.getImageData(0,0,1,1).data;
    const hsv = rgbToHsv(r, g, b);
    
    // ã‚¹ãƒã‚¤ãƒˆã§å–å¾—ã—ãŸè‰²ã‚’ãƒã‚¹ã‚¯è‰²ã«è¨­å®š
    const hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    redBoxConfig.maskColor = hex;
    els.maskColorInput.value = hex;

    document.getElementById('slider-h').setValues(Math.max(0, hsv[0]-15), Math.min(180, hsv[0]+15));
    document.getElementById('slider-s').setValues(Math.max(0, hsv[1]-60), Math.min(255, hsv[1]+60));
    document.getElementById('slider-v').setValues(Math.max(0, hsv[2]-60), Math.min(255, hsv[2]+60));
    if (isModal) closePickModalAndRun(true);
  }

  function rgbToHsv(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, v = max;
    let d = max - min;
    s = max == 0 ? 0 : d / max;
    if (max == min) h = 0;
    else {
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return [Math.round(h * 179), Math.round(s * 255), Math.round(v * 255)];
  }

  // --- æ‰‹å‹•ãƒˆãƒªãƒŸãƒ³ã‚°ãƒ¢ãƒ¼ãƒ€ãƒ« ---
  function openManualCrop(index, e) {
    if(e) e.stopPropagation();
    currentEditIndex = index;
    
    // å‰å›ã®cropperç ´æ£„
    if (cropper) {
        cropper.destroy();
        cropper = null;
    }

    els.cropModal.classList.add('active');
    
    // ç”»åƒãƒ­ãƒ¼ãƒ‰å¾Œã«CropperåˆæœŸåŒ–
    els.cropTarget.onload = () => {
      const detectRect = images[index].detectRect;
      
      const options = {
        viewMode: 1,
        autoCropArea: 0.9,
        responsive: true,
        checkCrossOrigin: false,
        ready: function() {
          if (detectRect) {
            this.cropper.setData(detectRect);
          }
        }
      };
      
      cropper = new Cropper(els.cropTarget, options);
    };

    // ç”»åƒã‚½ãƒ¼ã‚¹ã‚’è¨­å®šï¼ˆonloadã‚’ãƒˆãƒªã‚¬ãƒ¼ã™ã‚‹ãŸã‚æœ€å¾Œã«ï¼‰
    els.cropTarget.src = images[index].originalUrl; 
  }

  function closeModal(id) {
    document.getElementById(id).classList.remove('active');
    if (id === 'cropModal' && cropper) { cropper.destroy(); cropper = null; }
    if (id === 'redBoxModal') { redBoxResizeObserver.unobserve(els.redBoxTargetImage); } // ç›£è¦–åœæ­¢
  }
  async function applyManualCrop() {
    if (!cropper) return;
    
    const data = cropper.getData(); // å…ƒç”»åƒãƒ™ãƒ¼ã‚¹ã®åˆ‡ã‚ŠæŠœãåº§æ¨™ãƒ»ã‚µã‚¤ã‚º
    
    // ä¿®æ­£: ã‚¢ãƒƒãƒ—ã‚¹ã‚±ãƒ¼ãƒ«å¾Œã®ã‚µã‚¤ã‚ºã‚’æ•´æ•°ã§è¨ˆç®—
    // Canvasã®ã‚µã‚¤ã‚ºã¯æ•´æ•°ã§ãªã„ã¨ã¼ã‚„ã‘ã‚‹åŸå› ã«ãªã‚‹ãŸã‚Math.roundã‚’ä½¿ç”¨
    const targetWidth = Math.round(data.width * CROP_SCALE);
    const targetHeight = Math.round(data.height * CROP_SCALE);

    const canvas = cropper.getCroppedCanvas({
        width: targetWidth,
        height: targetHeight,
        imageSmoothingEnabled: true,
        imageSmoothingQuality: 'high'
    });
    
    const newUrl = canvas.toDataURL('image/jpeg', 0.95);
    images[currentEditIndex].croppedUrl = newUrl;
    
    // èµ¤æ ãŒã‚ã‚Œã°å†é©ç”¨
    if(redBoxes.length > 0) {
      images[currentEditIndex].dataUrl = await drawRedBoxesOnImage(newUrl);
    } else {
      images[currentEditIndex].dataUrl = newUrl;
    }
    
    images[currentEditIndex].isEdited = true;
    renderGrid();
    updatePdfPreview();
    closeModal('cropModal');
  }

  // --- ç·¨é›†æ“ä½œ ---
  window.removeImage = (i, e) => { 
    if(e) e.stopPropagation(); 
    images.splice(i, 1); 
    renderGrid(); 
    updatePdfPreview(); 
  };
  
  window.undoEdit = async (i, e) => {
    if(e) e.stopPropagation();
    images[i].croppedUrl = images[i].originalUrl;
    images[i].detectRect = null; // æ¤œå‡ºæƒ…å ±ã‚‚ãƒªã‚»ãƒƒãƒˆ
    
    // èµ¤æ ãŒã‚ã‚Œã°å†é©ç”¨
    if(redBoxes.length > 0) {
      images[i].dataUrl = await drawRedBoxesOnImage(images[i].originalUrl);
    } else {
      images[i].dataUrl = images[i].originalUrl;
    }
    
    images[i].isEdited = false;
    renderGrid();
    updatePdfPreview();
  };
  window.clearAll = () => { images = []; redBoxes = []; renderGrid(); updatePdfPreview(); };
  
  function resetAllProcessing() {
    // çŠ¶æ…‹ã‚’å®Œå…¨ãƒªã‚»ãƒƒãƒˆ
    images.forEach(img => {
      img.dataUrl = img.originalUrl;
      img.croppedUrl = img.originalUrl;
      img.detectRect = null;
      img.isEdited = false;
    });
    redBoxes = [];
    
    // å†æç”»
    renderGrid();
    updatePdfPreview();
    updateButtonStates();
  }

  // --- ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ä¸¦ã¹æ›¿ãˆ ---
  let dragSrcEl = null;
  function setupDragAndDrop() {
    const items = document.querySelectorAll('.preview-item');
    items.forEach(item => {
      item.addEventListener('dragstart', function(e) {
        this.classList.add('dragging');
        dragSrcEl = this;
        e.dataTransfer.effectAllowed = 'move';
      });
      item.addEventListener('dragover', function(e) { if (e.preventDefault) e.preventDefault(); return false; });
      item.addEventListener('drop', function(e) {
        e.stopPropagation();
        if (dragSrcEl !== this) {
          const srcIdx = parseInt(dragSrcEl.getAttribute('data-index'));
          const dstIdx = parseInt(this.getAttribute('data-index'));
          const [moved] = images.splice(srcIdx, 1);
          images.splice(dstIdx, 0, moved);
          renderGrid(); updatePdfPreview();
        }
        return false;
      });
      item.addEventListener('dragend', function() { this.classList.remove('dragging'); });
    });
  }

  // --- PDFç”Ÿæˆé–¢é€£ ---
  function updatePdfPreview() {
    const orientation = els.orientation.value;
    const imagesPerPage = parseInt(els.imagesPerPage.value);
    const margin = parseInt(els.margin.value);
    els.pdfPage.className = `pdf-page-preview ${orientation}`;
    if (images.length === 0) { els.pdfPage.innerHTML = ''; return; }
    const cols = Math.ceil(Math.sqrt(imagesPerPage));
    const rows = Math.ceil(imagesPerPage / cols);
    let html = `<div class="pdf-grid-preview" style="grid-template-columns: repeat(${cols}, 1fr); grid-template-rows: repeat(${rows}, 1fr); padding:${margin/2}px">`;
    for (let i = 0; i < imagesPerPage; i++) {
      if (i < images.length) html += `<div class="pdf-cell-preview"><img src="${images[i].dataUrl}"></div>`;
      else html += `<div class="pdf-cell-preview"></div>`;
    }
    html += '</div>';
    els.pdfPage.innerHTML = html;
  }

  // --- å…±é€šãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–¢æ•° (Canvasç”Ÿæˆ) ---
  // æŒ‡å®šãƒšãƒ¼ã‚¸ã®å†…å®¹ã‚’æç”»ã—ãŸCanvasã‚’è¿”ã™
  async function renderPageToCanvas(pageIndex, totalPages, config) {
    const { orientation, format, imagesPerPage, margin } = config;
    const widthMm = (format === 'a3' ? (orientation === 'portrait' ? 297 : 420) : (orientation === 'portrait' ? 210 : 297));
    const heightMm = (format === 'a3' ? (orientation === 'portrait' ? 420 : 297) : (orientation === 'portrait' ? 297 : 210));
    
    // ç”»è³ªè¨­å®š (DPIç›¸å½“)
    // ä¿®æ­£: è§£åƒåº¦ã‚’å‘ä¸Š (3 -> 5)
    const scale = 5; 
    const canvas = document.createElement('canvas');
    canvas.width = Math.floor(widthMm * scale);
    canvas.height = Math.floor(heightMm * scale);
    const ctx = canvas.getContext('2d');
    
    // ç™½èƒŒæ™¯
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const cols = Math.ceil(Math.sqrt(imagesPerPage));
    const rows = Math.ceil(imagesPerPage / cols);
    const cellW_mm = (widthMm - margin * 2) / cols;
    const cellH_mm = (heightMm - margin * 2) / rows;
    
    const startIdx = pageIndex * imagesPerPage;
    const endIdx = Math.min(startIdx + imagesPerPage, images.length);
    
    ctx.fillStyle = 'black';
    ctx.textAlign = 'center';
    // ãƒ™ãƒ¼ã‚¹ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º
    const baseFontSize = 8 * scale;
    
    // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´ç”¨å®šæ•° (mm)
    const cellGap_mm = 4; // ç”»åƒå‘¨å›²ã®éš™é–“
    const textAreaH_mm = 8; // ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢é«˜ã•
    
    for (let i = startIdx; i < endIdx; i++) {
      const posIndex = i - startIdx;
      const c = posIndex % cols;
      const r = Math.floor(posIndex / cols);
      
      const x_mm = margin + c * cellW_mm;
      const y_mm = margin + r * cellH_mm;
      
      // ç”»åƒãŒæç”»ã§ãã‚‹æœ€å¤§é ˜åŸŸï¼ˆéš™é–“ã¨ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã‚’é™¤ãï¼‰
      const availableW_mm = cellW_mm - (cellGap_mm * 2);
      const availableH_mm = cellH_mm - textAreaH_mm - (cellGap_mm * 2);
      
      const imgData = images[i].dataUrl;
      const imgEl = await loadImage(imgData);
      
      const imgRatio = imgEl.width / imgEl.height;
      const areaRatio = availableW_mm / availableH_mm;
      
      let w_mm, h_mm;
      if (imgRatio > areaRatio) {
        w_mm = availableW_mm;
        h_mm = w_mm / imgRatio;
      } else {
        h_mm = availableH_mm;
        w_mm = h_mm * imgRatio;
      }
      
      // ä¸­å¤®é…ç½®ï¼ˆéš™é–“åˆ†ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰
      const dx_mm = x_mm + cellGap_mm + (availableW_mm - w_mm) / 2;
      const dy_mm = y_mm + cellGap_mm + (availableH_mm - h_mm) / 2;
      
      // ç”»åƒæç”»
      ctx.drawImage(imgEl, dx_mm * scale, dy_mm * scale, w_mm * scale, h_mm * scale);
      
      // ãƒ†ã‚­ã‚¹ãƒˆæç”» (ç”»åƒä¸‹4mm + ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³èª¿æ•´)
      const text = images[i].name;
      const tx_mm = dx_mm + w_mm / 2; // ç”»åƒä¸­å¤®
      const ty_mm = dy_mm + h_mm + 4 + 2; 
      
      // ä¿®æ­£: ãƒ†ã‚­ã‚¹ãƒˆå¹…èª¿æ•´ (ç„¡ç†ãªé•·ä½“ã§ã¯ãªããƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºç¸®å°ã§å¯¾å¿œ)
      const maxTextWidth = w_mm * scale;
      let currentFontSize = baseFontSize;
      
      // ãƒ•ã‚©ãƒ³ãƒˆè¨­å®šï¼šè¦–èªæ€§ã®é«˜ã„ç­‰å¹…ãƒ•ã‚©ãƒ³ãƒˆã€ŒRoboto Monoã€ã‚’å„ªå…ˆ
      // æ—¥æœ¬èªã¯ã‚·ã‚¹ãƒ†ãƒ ãƒ•ã‚©ãƒ³ãƒˆï¼ˆNoto Sans JPãªã©ï¼‰ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      ctx.font = `500 ${currentFontSize}px 'Roboto Mono', 'Noto Sans JP', sans-serif`;
      
      const textMetrics = ctx.measureText(text);
      if (textMetrics.width > maxTextWidth) {
          // å¹…ã«åã¾ã‚‹ã‚ˆã†ã«æ¯”ç‡è¨ˆç®—ã—ã¦ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’è½ã¨ã™
          const ratio = maxTextWidth / textMetrics.width;
          currentFontSize = Math.floor(baseFontSize * ratio);
          // æ¥µç«¯ã«å°ã•ããªã‚Šã™ããªã„ã‚ˆã†ä¸‹é™ã‚’è¨­ã‘ã‚‹
          if (currentFontSize < 3 * scale) currentFontSize = 3 * scale;
          ctx.font = `500 ${currentFontSize}px 'Roboto Mono', 'Noto Sans JP', sans-serif`;
      }

      ctx.fillText(text, tx_mm * scale, ty_mm * scale);
    }
    
    return canvas;
  }

  // --- å‡ºåŠ›ç”Ÿæˆãƒ¡ã‚¤ãƒ³ ---
  async function generateOutput() {
    if (images.length === 0) return;
    
    const mode = document.querySelector('input[name="outputMode"]:checked').value;
    const isImageMode = (mode === 'image-file');
    const isRasterPdf = (mode === 'pdf-image');
    
    const loadingText = isImageMode ? 'ç”»åƒç”Ÿæˆä¸­...' : 'PDFç”Ÿæˆä¸­...';
    showStatus(true, loadingText);
    await new Promise(r => setTimeout(r, 100)); // UIæ›´æ–°å¾…ã¡

    try {
      const orientation = els.orientation.value;
      const format = els.pageSize.value;
      const imagesPerPage = parseInt(els.imagesPerPage.value);
      const margin = parseInt(els.margin.value);
      const config = { orientation, format, imagesPerPage, margin };
      
      const totalPages = Math.ceil(images.length / imagesPerPage);

      if (isImageMode) {
        // --- ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ãƒ¢ãƒ¼ãƒ‰ ---
        const zip = new JSZip();
        for (let p = 0; p < totalPages; p++) {
          const canvas = await renderPageToCanvas(p, totalPages, config);
          const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.95));
          const fileName = `page_${p + 1}.jpg`;
          
          if (totalPages === 1) {
             saveAs(blob, fileName);
             showStatus(false);
             return;
          }
          zip.file(fileName, blob);
        }
        const content = await zip.generateAsync({type:"blob"});
        saveAs(content, "combined_images.zip");

      } else if (isRasterPdf) {
        // --- PDF (ä¸­èº«ç”»åƒåŒ–) ãƒ¢ãƒ¼ãƒ‰ ---
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation, unit: 'mm', format });
        const widthMm = doc.internal.pageSize.getWidth();
        const heightMm = doc.internal.pageSize.getHeight();

        for (let p = 0; p < totalPages; p++) {
          if (p > 0) doc.addPage();
          const canvas = await renderPageToCanvas(p, totalPages, config);
          const imgDataUrl = canvas.toDataURL('image/jpeg', 0.95);
          doc.addImage(imgDataUrl, 'JPEG', 0, 0, widthMm, heightMm, `PAGE_${p}`, 'FAST');
        }
        doc.save('combined_images.pdf');

      } else {
        // --- PDF (ãƒ†ã‚­ã‚¹ãƒˆä¿æŒ) ãƒ¢ãƒ¼ãƒ‰ ---
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation, unit: 'mm', format });
        const pW = doc.internal.pageSize.getWidth();
        const pH = doc.internal.pageSize.getHeight();
        const cols = Math.ceil(Math.sqrt(imagesPerPage));
        const rows = Math.ceil(imagesPerPage / cols);
        const cellW = (pW - margin * 2) / cols;
        const cellH = (pH - margin * 2) / rows;
        
        // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´ç”¨å®šæ•° (mm)
        const cellGap = 4; // ç”»åƒå‘¨å›²ã®éš™é–“
        const textAreaH = 8; // ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢é«˜ã•

        for (let i = 0; i < images.length; i++) {
          if (i > 0 && i % imagesPerPage === 0) doc.addPage();
          const imgData = images[i].dataUrl;
          const imgEl = await loadImage(imgData);
          const posIndex = i % imagesPerPage;
          const c = posIndex % cols;
          const r = Math.floor(posIndex / cols);
          const x = margin + c * cellW;
          const y = margin + r * cellH;
          
          // ç”»åƒãŒæç”»ã§ãã‚‹æœ€å¤§é ˜åŸŸ
          const availableW = cellW - (cellGap * 2);
          const availableH = cellH - textAreaH - (cellGap * 2);
          
          const imgRatio = imgEl.width / imgEl.height;
          const areaRatio = availableW / availableH;
          
          let w, h;
          if (imgRatio > areaRatio) {
             w = availableW;
             h = w / imgRatio;
          } else {
             h = availableH;
             w = h * imgRatio;
          }
          
          // é…ç½®ä½ç½®ï¼ˆä½™ç™½åˆ†ãšã‚‰ã™ï¼‰
          const dx = x + cellGap + (availableW - w) / 2;
          const dy = y + cellGap + (availableH - h) / 2; 
          
          const safeAlias = (images[i].name.replace(/[^a-zA-Z0-9]/g, '_') + '_' + i).substring(0, 50);
          doc.addImage(imgData, 'JPEG', dx, dy, w, h, safeAlias);
          
          // ãƒ†ã‚­ã‚¹ãƒˆå¹…èª¿æ•´ (ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºç¸®å°)
          let fontSize = 8;
          doc.setFontSize(fontSize);
          const text = images[i].name;
          
          // å¹…ãŒç”»åƒå¹…ã‚’è¶…ãˆã‚‹å ´åˆã¯ç¸®å° (æœ€å°4pt)
          while (doc.getTextWidth(text) > w && fontSize > 4) {
              fontSize -= 0.5;
              doc.setFontSize(fontSize);
          }

          // ç”»åƒä¸­å¤®ã«é…ç½®
          const tx = dx + w / 2 - doc.getTextWidth(text) / 2;
          const ty = dy + h + 4; // ç”»åƒä¸‹4mmã«é…ç½®ã—ã¦è¢«ã‚Šé˜²æ­¢
          
          doc.text(text, tx, ty);
        }
        doc.save('combined_images.pdf');
      }
      
      showStatus(false);
    } catch(e) { 
      console.error(e); 
      alert('ä¿å­˜ã‚¨ãƒ©ãƒ¼: ' + e.message); 
      showStatus(false); 
    }
  }

  function loadImage(src) { return new Promise((r, j) => { const i = new Image(); i.onload = () => r(i); i.onerror = j; i.src = src; }); }
  function showStatus(show, text = '') {
    if (show) { els.statusText.textContent = text; els.statusBar.classList.add('show'); }
    else { els.statusBar.classList.remove('show'); }
  }
</script>
</body>
</html>
